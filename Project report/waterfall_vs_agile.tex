\newpage

\section{Software development model}\label{sec:devmodel}

This section will describe the two different options we had for a software development model; waterfall and agile.

\subsection{Waterfall}
The waterfall model is a sequential design process that is often used in software development processes, in which progress is seen as a flow of water through the phases of conception, initiation analysis, construction, testing, production/implementation and at last maintenance \cite{bib:waterfall}. 
\newline
\newline
This is a model that was originally used in hardware industry, but in lack of a better model, was adapted for software development. In the waterfall model, each of the stages is sequential, and another phase starts where the previous ends. There is no room for different approaches here. Before implementations of a software product, the documentation has to be carved in stone. If, for example, the documentation is only half done, it will ruin the whole process. Therefore, one has to be entirely sure that a phase is over before a new one begins. 

\subsection{Agile}
Agile development is based on interative and incremental development, and promotes a workflow process that embraces change \cite{bib:agile}. The Agile Manifesto states that we get better software by concentrating on the software itself, the customers receiving the software and focusing on the team dynamic of the development team as well as responding to changes as they arrive. A lot of software development processes has emerged from the agile development method. We will now discuss two of them, which is the two most relevant to consider for this project. 

\subsubsection{Kanban}
Kanban Development is a fully transparent process that has an emphasis on just-in-time delivery where the main focus is not to overload the developers \cite{bib:kanban}. It consists of Kanban, which is a process board, which is a overview of what to produce, when to produce it, and how much to produce; and the Kanban method itself. It is an agile software development method that uses a pull system to find problems and encourage change.  What is important to notice about the Kanban development process, is that it is not a process in the way that we have a series of steps from start to finish. We just focus on what is good in the current development environment and stimulate further change. In order for this to work, we must respect the  process of development, the roles of the team, their respective responsibilities and their title.

\newpage

\subsubsection{Scrum}
Scrum is used in agile software development. Rather than being a full description of the process of software development, it is a framework setting the boundaries for the software development team \cite{bib:asdas}. The reason this is done is because the team knows best how to solve the task they are presented with.
\newline
\newline
Scrum relies on a self-organizing, cross functional team. This means that there is no team leader who decides who will do what. This also sets a boundary on the maximum size of team, which is about eight to ten persons.
\newline
\newline
The development cycle is created by basic units, called a sprint. These sprints last between one week and one month \cite{bib:scrum}. In the start of each sprint, there is a planning meeting, where tasks are defined and goals are made. The tasks are taken from the backlog (in scrum terminology: "defined from"), and are refined into a task specification which can be performed by a programmer. During each sprint, a part of the completed product is made. It is not unusual to create a basic version of the complete software during the first sprint, and then add more functions as we go, during the later sprints.
\newline
\newline
Each day during a sprint starts with a scrum meeting. The main purpose of this meeting is to give everyone a status report of what is going on. Each member of the group summarizes what he has done, what he is about to do, and what stands in his way of doing his tasks. These meetings have a maximum duration of 15 minutes, and should be done standing, as this keeps the talks short and effective.
\newline
\newline
The organization of the groups tasks is done by using the scrum task board. Here, one can see which tasks are unassigned, in progress, in testing and done. As the group consists of few persons, most of organization can be done via direct communication from person to person or during the meeting.


\subsection{Software development model discussion}
Software development projects are either agile, like scrum, or based on a more rigid model like the waterfall model. There are reasons that they both coexist today. There are both positive and negative aspects of both of them. 
\newline
\newline
Supporting arguments for using the waterfall model are many. By using as much time as possible on the early stages of software will eliminate problems later on. If we see that something is impossible to implement, we can find a new solution, and still use no extra time on the coding phase of the software. 

\newpage

As the waterfall model is a rigid development method, a lot of documentation is done. This may be seen as bureaucracy, but it has one huge advantage; all code is well documented, which means that if all the developers of a project decides to quit, a new team of developers can read up on the documentation and continue where the others left. This makes the waterfall model good for projects that do not change over time and where documentation is of outmost importance. It is, for example, very clear that a software system that keeps an airplane in the air, cannot be developed using an agile process where there exists little or no documentation. Life critical systems like these must go through bureaucracy to maintain the levels of reliability that is needed. 
\newline
\newline
On the other hand, there are also many supporting arguments of an agile process. One of the most central ones are customer awareness. In an agile process, the developers know that the customers might change their minds. Or said in another way: They know the customers will change their mind. An agile process will not see this as a problem, as changes can easily be incorporated into the next build of the software. In a waterfall model, there is no way of accomodating changes when coding has started. If one sees that a part of the software is difficult to implement in an agile process, it is just a matter of finding a new way of getting the task done and then implement it.  This makes agile processes perfect for fast changing environments where the software is in constant change or when the developing firm is unsure about certain aspects of the software, but know approximately which direction to take it.  
\newline
\newline
Another supporting argument for agile processes is that these are low cost processes. Almost no time is used on time consuming documentation that will never be read. Almost all time is used on developing the software, and is therefore more efficient. 

\subsection{Software development model conclusion}
As we can see, there are many pros and cons of both agile processes and waterfall models. In the context of this Customer Driven Project, it seems most benefitial to use scrum, as the specifications are unclear. We are not sure how long the documentation or the development process will take, so both activites will be done continuously. Going for a waterfall model will give us little or no room for error. With the experience of this developing team, it would be ridicolous to think that we would go through the entire project without making mistakes. 
\newline
\newline
We could go for a Kanban process, but it is a bit hard to rely on the existing structure of the group when there is no such thing. In a group where we do not know how we are going to organize the group, it is best to go for a model where we have some rigidity in the process itself to help us find the right direction. 
\newline
\newline
We have chosen scrum as our group organization model, as it fits this projects size and timeframe. There is a lot of uncertainty in our project regarding how we should organize the project from start to finish, as well as a limited time frame. The limited time frame forces us to make choices on which features we are able to implement.  But, as we are able to see what needs to be done in the near future (three weeks to one month), we can divide the project into sprints of this size and create a more detailed description of each task as we go.

