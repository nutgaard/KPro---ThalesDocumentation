

\section{Technical opportunities}

\subsection{Remote vs. local service}

As the requirements document states the application should be able to receive messages even when the application is not running. Fortunately the android platform facilitates this functionality in the form of a `Service`[12]. But in order to utilize this feature effectively some key architectural decisions must be made, the biggest one being if the Service should run in the same process as the application itself(local service), or if it should have its own process(remote service). Although the choice of can be made transparent to the rest of the application, there are some key differences that must be considered.

\subsubsection{Resource footprint}
As stated above, a remote service will run in its own process. This means that the application will allocate two processes worth of memory in order to run. It will also require more from the CPU since any call to the service will require the CPU to switch to another process. These two drawback are mitigated by the use of a local service, where the service runs in the same process as the application. 

\subsubsection{Communication with service}
For a remote service you will have to use some sort of  interprocess communication(IPC), on the android platform this is solved by the use of `Android Interface Definition Language`(AIDL)[13]. Whereas for a local service a simple IBinder[14] is needed. With respect to modifiability the latter is the best solution since the developer does not update AIDL files whenever an interface changes, nor does he/she have manage the intricate process of breaking down object used in the application down to primary types for sending over IPC. 



