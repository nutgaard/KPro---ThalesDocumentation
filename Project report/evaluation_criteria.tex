\section{Evaluation and Conclusion}

\subsection{Similar solutions conclusion}
It is very clear that a similar solution to XOXOmail is not available on the market, but there exist solutions that partially try to implement \gls{emims}, like \gls{k9m}. There also exist solutions that fully implement \gls{emims} for external clients like X509Tools. A problem with using \gls{x5}, is gives poor performance to apps that utilize this \gls{emims} capability, as the mail message will have to be stored to disk between the mail client and \gls{x5}. An alternative is therefore to use \gls{r2m2}, which gives all one can want regarding security.
\newline
\newline
As an aside, it is of interest to note that we have been in direct contact with on of the developers of \gls{x5} and \gls{r2m2}. His name was Stefan Selbitschka, and he was very interested in this project. If necessary, he could build us a separate version of the \gls{r2m2} library that incorporates e.g. header specific data that is unique to XOXOmail. This was mentioned at a meeting with Thales, but no discussion was further made on this topic. It seems that it is more important to investigate possible solutions than to brute force a fast solution to the prototype of XOXOmail.
\newline
\newline
Even though there exist email clients on the market where security is important, none of these have the special needs that XOXOmail will have to fulfill. This is mainly because XOXOmail is a specialized software created for a specific user group. A general purpose app will never be able to fulfill these requirements. It is therefore clear that XOXOmail has to be implemented ground up to get the capabilities we are looking for. We can still use a lot of knowledge regarding what works well and not so well in other mail applications in our product, as the basic functionality is quite similar.

\subsection{Software development model conclusion}
Software development projects are either agile, like Scrum,  or based on a more rigid model like the waterfall model. There are reasons that they both co-exist today. There is both positive and negative aspects of both of them. 
\newline
\newline
Supporting arguments for using the waterfall model are many. By using as much time as possible on the early stages of software will eliminate problems later on. If we see that something is impossible to implement, we can find a new solution, and still use no extra time on the coding phase of the software. 
\newline
\newline
As the waterfall model is a rigid development method, a lot of documentation is done. This may be seen as bureaucracy, but it has one huge advantage; all code is well documented, which means that if all the developers of a project decides to quit, a new team of developers can read up on the documentation and continue where the others left. This makes the waterfall model good for projects that do not change over time and where documentation is of outmost importance. It is, for example, very clear that a software system that keeps an airplane in the air, cannot be developed using an agile process where there exists little or no documentation. Life critical systems like these must go through bureaucracy to maintain the levels of reliability that is needed. 
\newline
\newline
On the other hand, there are also many supporting arguments of an agile process. One of the most central ones are customer awareness. In an agile process, the developers know that the customers might change their minds. Or said in another way: They know the customers will change their mind. An agile process will not see this as a problem, as changes can easily be incorporated into the next build of the software. In a waterfall model, there is no way of accomodating changes when coding has startes. If one sees that a part of the software is difficult to implement in an agile process, it is just a matter of finding a new way of getting the task done and then implement it.  This makes agile processes perfect for fast changing environments where the software is in constant change or when the developing firm is unsure about certain aspects of the software, but know in which direction to take it.  
\newline
\newline
Another supporting argument for agile processes is that these are low cost processes. Almost no time is used on time consuming documentation that will never be read. Almost all time is used on developing the software, and is therefore more efficient. 
\newline
\newline
As we can see, there are many pros and cons of both agile processes and waterfall models. In the context of this customer driven project, it seems most benefitial to use Scrum, as the specifications are unclear. We are not sure how long the documentation or the development process will take, so both activites will be done continously. Going for a waterfall model will give us little or no room for error. With the experience of this developing team, it would be ridicolous to think that we would go through the entire project without making mistakes. 
\newline
\newline
We could go for a Kanban process, but it is a bit hard to rely on the existing structure of the group when this is non-existing. In a group where we donâ€™t know how we are going to organize the group, it is best to go for a model where we have some rigidity in the process itself to help us in the right direction. 
\newline
\newline
We have chosen Scrum as our group organization model, as it fits this projects size and timeframe. There is a lot of uncertainty in our project regarding how we should organize the project from start to finish, as well as a limited time frame. The limited time frame forces us to make choices on which features we are able to implement.  But, as we are able to see what needs to be done in the near future (three weeks to one month), we can divide the project into sprints of this size and create a more detailed description of each task as we go.

\subsection{Programming languages conclusion}
As we have seen, there are many ways to create software for Android. One can rely on only one language for programming, or use a combination of languages. We have chosen to develop purely on a Java platform. Why is this relevant for us, as we are creating an Android application?
\newline
\newline
First, it is the most used developing language for Android, which means we are using a well tested and documented development framework. It is unlikely that we will run into big problems. Second, we are all familiar with using Java, so the learning curve will only be a bit steep for those in the group that are new at Android development.  Another benefit of using Java is that, if we decide on implementing a server part, we can create the server first and then decide if we want it to run on the phone or on a computer, be that a Linux or Windows computer or something else. This flexibility is something we only can get from Java.
\newline
\newline
We chose Java as our main programming language as this is the most widespread language and has most support online. It is the language which has been pushed forward the most from Google, and is the recommended language to write Android apps.

\subsubsection{Markup languages conclusion}
\gls{xml} is a widespread exchange format which has a lot of libraries that can be used to generate \gls{xml} data. Even though, it is known that \gls{xml} is primarily a document exchange format, where as \gls{json} is better suited for data exchange. This means that \gls{json} often is much more readable, as the mapping between objects in programming and \gls{json} representation is much more alike. As a result, the \gls{json} code is easier for machines to read and write. \gls{json} is becoming more and more common, and is now widely adopted by the computer industry. Still, the format is irrelevant for us, as we will be using a serializer and deserializer that ensures that syntax is correct, so we will use a \gls{xml}-serializer. 

\subsection{Remote vs. local service conclusion}
There was little that supported the use of a remote service for this application, so the natural choice is the local service, both for its ease of use and performance.

\subsection{Secure communication conclusion}
There exist several methods which can be used to secure a communication channel, some more prominent than others. Secure communication could in theory be implemented at every level of the TCP/IP 5-layer reference model \cite{bib:cn}/"Internet model" \cite{bib:rfc1122}. The first option was to create our own secure protocol at the application layer that would provide a transparent wraparound of the transport layer, but this is rarely an optimal solution and will probably result in a poor and insecure imitation of an existing solution.
\newline
\newline
Second, we choose a lower level, as to implement encryption on the network or link layer \cite{bib:techtarget}. For network layer encryption it would be possible to use \gls{ips}, this is however not possible through Java or Android \cite{bib:ispec} but would require interfering with the operating system beneath.  The same can be said about link layer solutions; it would require interference with the operating system. But compared the link layer encryption relies on the security of each link host, something that cannot be guaranteed when sending over the Internet.
\newline
\newline
Third we have the option of using a pre-existing application/transport layer protocol like \gls{ssl1}/\gls{tls}. In order to maximize security gain it is recommended to use \gls{tls} 1.2 \cite{bib:ssl}  which has improved security relative to earlier version of \gls{tls} and \gls{ssl1}.

\subsection{Secure storage conclusion}
If we chose to create custom account types it would involve a lot of server side implementation that would be time consuming and problematic. So we should try to avoid this solution. The two other possibilities are both valid ones if we make certain assumptions.
\newline
\newline
If we are going to implement the version where username and password is saved in the local storage we would need to assume that no unwanted physical access to the phone will occur. Given this assumption this would be the best and easiest solution to implement.
\newline
\newline
To implement the secure storage with derived keys we need to assume there will be no problem for the user to log in every time he starts the application. This will make sure the information is secure even though the phone should get misplaced or stolen, but this is more complicated to implement than saving the credentials locally.

\subsection{Wireshark conclusion}
Sending and receiving messages with our application over GSM seems to work in a respectable manner. The time it takes to receive and send messages is pretty good considering this was done over 14.4 kbits/s. The TLS protocol also seems to be working as intended for both sending and receiving messages. The initial handshake is completed and the following data is encrypted as it should be. 
\newline
\newline
The only problem we could find is that the amount of data sent when considering both the sending and receiving functionality appears to be much larger than the actual size of the message when you inspect it in clear text. The receiving part of the application had an increase of 66.47% whilst the sending part had an increase of 42.7%. 
\newline
\newline
At first we thought this could be a result of the TLS encryption of the data, but if the encryption is working as intended the only part of the encryption that could create some overflow is the initial handshake. This was not included in the calculation, only the actual application data sent or received was included. The actual encrypted TLS packages are based on relatively efficient symmetric ciphers and should not take up a lot more space than unencrypted packages.  
\newline
\newline
It is difficult to pinpoint the exact reason for this large increase in data transferred at this point, but it was sent in a reasonable time and according to protocol, and those are the most important attributes for our client.  

\subsection{Compression of data conclusion}
We have now gone through a lot of methods for both lossy and lossless compression and it is evident that there are many choices. The intention of this compression study was merely to give an overview of what exists. We have not listed all options, but just peeked into some of the most interesting methods. In order to give a qualified answer to what is the best algorithms, a more thorough study has to be done in order to find the requirements on compression time in relation with connection speed, what Android devices will be using the algorithms and what algorithms that have a working implementation for android.  